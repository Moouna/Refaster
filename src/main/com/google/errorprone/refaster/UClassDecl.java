/*
 * Copyright 2013 Google Inc. All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.google.errorprone.refaster;

import static com.google.common.base.Preconditions.checkArgument;

import com.google.auto.value.AutoValue;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Iterables;

import com.sun.source.tree.ClassTree;
import com.sun.source.tree.MethodTree;
import com.sun.source.tree.ModifiersTree;
import com.sun.source.tree.Tree;
import com.sun.source.tree.TreeVisitor;
import com.sun.source.tree.TypeParameterTree;
import com.sun.tools.javac.tree.JCTree;
import com.sun.tools.javac.tree.JCTree.JCClassDecl;
import com.sun.tools.javac.util.List;

import java.util.Iterator;

import javax.annotation.Nullable;
import javax.lang.model.element.Name;

/**
 * {@code UTree} representation of a {@code ClassTree} for anonymous inner class matching.
 * 
 * @author lowasser@google.com (Louis Wasserman)
 */
@AutoValue
public abstract class UClassDecl extends UStatement implements ClassTree {
  public static UClassDecl create(UMethodDecl... members) {
    return create(ImmutableList.copyOf(members));
  }
  
  public static UClassDecl create(Iterable<UMethodDecl> members) {
    checkArgument(Iterables.size(members) <= 1,
        "UClassDecl does not currently support multi-method anonymous classes");
    return new AutoValue_UClassDecl(ImmutableList.copyOf(members));
  }

  @Override
  @Nullable
  public Unifier visitClass(ClassTree node, @Nullable Unifier unifier) {
    // We want to skip e.g. autogenerated init members, so we do this by hand...
    Iterator<UMethodDecl> membersItr = getMembers().iterator();
    for (Tree targetMember : node.getMembers()) {
      if (targetMember instanceof MethodTree) {
        MethodTree targetMethodDecl = (MethodTree) targetMember;
        if (targetMethodDecl.getReturnType() != null) {
          unifier = membersItr.hasNext()
              ? membersItr.next().unify(targetMethodDecl, unifier)
              : null;
        }
      }
    }
    return membersItr.hasNext() ? null : unifier;
  }

  @Override
  public JCClassDecl inline(Inliner inliner) throws CouldNotResolveImportException {
    return inliner.maker().AnonymousClassDef(
        inliner.maker().Modifiers(0L),
        List.convert(JCTree.class, inliner.inlineList(getMembers())));
  }
  
  @Override
  public <R, D> R accept(TreeVisitor<R, D> visitor, D data) {
    return visitor.visitClass(this, data);
  }

  @Override
  public Kind getKind() {
    return Kind.CLASS;
  }

  @Override
  public UTree<?> getExtendsClause() {
    return null;
  }

  @Override
  public ImmutableList<UTree<?>> getImplementsClause() {
    return ImmutableList.of();
  }

  @Override
  public abstract ImmutableList<UMethodDecl> getMembers();

  @Override
  public ModifiersTree getModifiers() {
    return null;
  }

  @Override
  public Name getSimpleName() {
    return null;
  }

  @Override
  public ImmutableList<TypeParameterTree> getTypeParameters() {
    return ImmutableList.of();
  }

}
